using "edom" : 0;

namespace "esvg" : 0 {
	/* basic types */
	struct "number","SVGNumber" {
		double "value";
	};

	struct "length","SVGLength" {
		double "value";
		int "unit";
	};

	struct "matrix","SVGMatrix" {
		double "a";
		double "b";
		double "c";
		double "d";
		double "e";
		double "f";
	};

	struct "rect","SVGRect" {
		double "x";
		double "y";
		double "width";
		double "height";
	};

	struct "rect_animated","SVGAnimatedRect" {
		SVGRect "base";
		SVGRect "anim";
	};

	/* the color needs a byte definition or int8 in ender */
	struct "color","SVGColor" {
		int "r";
		int "g";
		int "b";
	};

	struct "point","SVGPoint" {
		double "x";
		double "y";
	};

	struct "paint","SVGPaint" {
		int "type";
		SVGColor "color";
		string "uri";
	};

	/* FIXME remove the clippath */

	/* animated types */
	struct "number_animated","SVGAnimatedNumber" {
		double "base";
		double "anim";
	};

	struct "length_animated","SVGAnimatedLength" {
		SVGLength "base";
		SVGLength "anim";
	};

	struct "matrix_animated","SVGAnimatedMatrix" {
		SVGMatrix "base";
		SVGMatrix "anim";
	};

	struct "string_animated","SVGAnimatedString" {
		string "base";
		string "anim";
	};

	struct "boolean_animated","SVGAnimatedBoolean" {
		bool "base";
		bool "anim";
	};

	struct "animated_enum","SVGAnimatedEnum" {
		int "base";
		int "anim";
	};

	/* TODO add the enum constraints */
	struct "animated_display","SVGAnimatedDisplay" {
		int "base";
		int "anim";
	};
	/* TODO add the enum constraints */
	struct "animated_visibility","SVGAnimatedVisibility" {
		int "base";
		int "anim";
	};

	struct "color_animated","SVGAnimatedColor" {
		SVGColor "base";
		SVGColor "anim";
	};

	struct "paint_animated","SVGAnimatedPaint" {
		SVGPaint "base";
		SVGPaint "anim";
	};


	struct "animated_clip_path","SVGAnimatedClipPath" {
		string "base";
		string "anim";
	};

	union "duration","SVGDuration" {
		/* fix we should include the long variants on ender */
		long "clock";
	};

	struct "esvg_path_vline_to" {
		double "c";
	};

	union "esvg_path_command" {
		esvg_path_simple_line "hline";
		esvg_path_simple_line "vline";
	};

	struct "esvg_animated_path_command" {
		[esvg_path_command] "base";
		[esvg_path_command] "anim";
	};

	/* elements */

	abstract "element","SVGElement" : "tag" {
		/* core */
		int "type";
		/* dom */
		string "id";
		string "class";
		string "style";
		/* presentation attributes */
		esvg_animated_clip_path "clip-path";
		SVGAnimatedNumber "opacity";
		/* once the color is done we can the union paint for filling and stroking */
		SVGAnimatedColor "color";
		SVGAnimatedPaint "fill";
		SVGAnimatedPaint "stroke";
		SVGAnimatedLength "stroke-width";
		SVGAnimatedNumber "fill-opacity";
		SVGAnimatedNumber "stroke-opacity";
		esvg_animated_visibility "visibility";
		esvg_animated_display "display";
		SVGAnimatedColor "stop-color";
		SVGAnimatedNumber "stop-opacity";
		/* other attributes */
		SVGAnimatedMatrix "transform";
		ender "topmost";
		/* event attributes */
		string "onfocusin";
		string "onfocusout";
		string "onactivate";
		string "onclick";
		string "onmousedown";
		string "onmouseup";
		string "onmouseover";
		string "onmousemove";
		string "onmouseout";
	};

	abstract "referenceable","SVGReferenceable" : "SVGElement" {

	};

	abstract "renderable","SVGRenderable" : "SVGElement" {
		object "renderer";
	};

	abstract "paint_server","SVGPaintServer" : "SVGReferenceable" {

	};

	class "element_clip_path","SVGClipPathElement" : "SVGReferenceable" {
		int "clip_path_units";
	};

	abstract "element_gradient","SVGGradientElement" : "SVGPaintServer" {
		string "href";
		int "spread_method";
		int "gradient_units";
		SVGAnimatedMatrix "gradient_transform";
	};

	abstract "element_animation","SVGAnimationElement" : "SVGElement" {
		string "attribute_name";
		int "attribute_type";
		int "additive";
		int "accumulate";
		int "repeat_count";
		int "fill";
		/* FIXME later we should use a time object? */
		esvg_duration "dur";
		/* FIXME we use objects for now, we should use the real struct once it is defined */
		[object] "begin";
		[object] "end";
	};

	abstract "animate_base","SVGAnimateBase" : "SVGAnimation" {
		string "from";
		string "to";
		string "values";
		int "calc_mode";
		string "key_times";
		string "key_splines";
	};

	class "element_set","SVGSetElement" : "SVGAnimation" {
		string "to";
	};

	class "element_animate","SVGAnimateElement" : "SVGAnimateBase" {

	};

	class "element_animate_transform","SVGAnimateTransformElement" : "SVGAnimateBase" {
		int "type";
	};

	class "element_style","SVGStyleElement" : "SVGElement" {

	};

	class "element_linear_gradient","SVGLinearGradientElement" : "SVGGradientElement" {
		SVGLength "x1";
		SVGLength "y1";
		SVGLength "x2";
		SVGLength "y2";
	};

	class "element_radial_gradient","SVGRadialGradientElement" : "SVGGradientElement" {
		SVGAnimatedLength "cx";
		SVGAnimatedLength "cy";
		SVGAnimatedLength "fx";
		SVGAnimatedLength "fy";
		SVGAnimatedLength "r";
	};

	class "element_svg","SVGSVGElement" : "SVGRenderable" {
		SVGLength "x";
		SVGLength "y";
		SVGLength "width";
		SVGLength "height";
		SVGRect "viewbox";
		double "actual_width";
		double "actual_height";
		double "container_width";
		double "container_height";
		double "x_dpi";
		double "y_dpi";
		string "content_script_type";

		ender "element_get_by_id", "getElementById" (string);
	};

	class "element_g","SVGGElement" : "SVGRenderable" {

	};

	class "element_use","SVGUseElement" : "SVGRenderable" {
		SVGLength "x";
		SVGLength "y";
		SVGLength "width";
		SVGLength "height";
		string "link";
	};

	class "element_rect","SVGRectElement" : "SVGRenderable" {
		SVGAnimatedLength "x";
		SVGAnimatedLength "y";
		SVGAnimatedLength "width";
		SVGAnimatedLength "height";
		SVGAnimatedLength "rx";
		SVGAnimatedLength "ry";
	};

	class "element_ellipse","SVGEllipseElement" : "SVGRenderable" {
		SVGAnimatedLength "cx";
		SVGAnimatedLength "cy";
		SVGAnimatedLength "rx";
		SVGAnimatedLength "ry";
	};

	class "element_circle","SVGCircleElement" : "SVGRenderable" {
		SVGAnimatedLength "cx";
		SVGAnimatedLength "cy";
		SVGAnimatedLength "r";
	};

	class "element_path","SVGPathElement" : "SVGRenderable" {
		esvg_animated_path_command "d";
	};

	class "element_line","SVGLineElement" : "SVGRenderable" {
		SVGAnimatedLength "x1";
		SVGAnimatedLength "x2";
		SVGAnimatedLength "y1";
		SVGAnimatedLength "y2";
	};

	class "element_polyline","SVGPolylineElement" : "SVGRenderable" {
		[esvg_point] "point";
	};

	class "element_polygon","SVGPolygonElement" : "SVGRenderable" {
		[esvg_point] "point";
	};

	class "element_text","SVGTextElement" : "SVGRenderable" {
		SVGAnimatedLength "x";
		SVGAnimatedLength "y";
	};

	class "element_stop","SVGStopElement" : "SVGElement" {
		SVGLength "offset";
	};

	class "element_defs","SVGDefsElement" : "SVGElement" {

	};

	class "element_a","SVGAElement" : "SVGElement" {
		SVGAnimatedString "xlink:href";
	};

	class "element_image", "SVGImageElement" : "SVGRenderable" {
		SVGAnimatedLength "x";
		SVGAnimatedLength "y";
		SVGAnimatedLength "width";
		SVGAnimatedLength "height";
		SVGAnimatedString "xlink:href";
	};

	class "element_video","SVGVideoElement" : "SVGRenderable" {
		SVGAnimatedLength "x";
		SVGAnimatedLength "y";
		SVGAnimatedLength "width";
		SVGAnimatedLength "height";
		SVGAnimatedString "xlink:href";
	};

	class "element_script","SVGScriptElement" : "SVGElement" {
		string "content_script_type";
	};
};

